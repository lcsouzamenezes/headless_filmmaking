; Generated by AutoGUI 2.5.8
#SingleInstance Force
#NoEnv
SetWorkingDir %A_ScriptDir%
SetBatchLines -1

; https://github.com/hi5/CSV
#Include csv.ahk


; ********* MEM VARS ETC *************
global xKeys := []
global xCmds := []

global ffmpegPID
global CB_hvenc
CB_hvenc := 0
global hvenc_bitrate
hvenc_bitrate := 10000K

; Load our ffmpeg commands from our text file
CSV_Load("ffmpeg_commands.txt","xCmds_csv","|")
Rows := CSV_TotalRows("xCmds_csv")

Loop, % Rows
    {
    if A_Index > 1 ; not first heading row
        {
        xKeys.push(CSV_ReadCell("xCmds_csv",A_Index,1))
        xCmds.push(CSV_ReadCell("xCmds_csv",A_Index,2))
        }
    }

; ********** GUI WINDOW **************
Gui Add, Text, x32 y20 w400 h23 +0x200, Name capture as filename...
Gui Add, Edit, x32 y50 w400 h21 vCaptureFilename, webcam.mp4 ; default

Gui Add, Button, x32 y80 w200 h23 gCMDload_devices, &Load Available Capture Devices
Gui Add, Button, x250 y80 w160 h23 gCMDsave_devices, Save My Capture Devices
Gui Add, Text, x32 y110 w400 h23 +0x200, Video Capture Devices...

; Load saved device
;GuiControl,, MyDevicesDLL, |%ListDevices%
    if FileExist("MyCaptureDevices.txt")
    {
    CSV_Load("MyCaptureDevices.txt","mydevices","|")
    VideoDevice:=CSV_ReadCell("mydevices",2,2)
    ;msgbox %VideoDevice%
    }
Gui Add, DropDownList, x32 y140 w400 vMyDevicesDLL_Video, "%VideoDevice%"||

Gui Add, Text, x32 y170 w400 h23 +0x200, Audio Capture Devices...

if FileExist("MyCaptureDevices.txt")
    {
    AudioDevice:=CSV_ReadCell("mydevices",3,2)
    }
Gui Add, DropDownList, x32 y200 w400 vMyDevicesDLL_Audio, "%AudioDevice%"||

Gui Add, Text, x32 y230 w400 h23 +0x200, Use Pre-Set For Capture...
; LOAD from ARRAY above ( from CSV file )
flagFirst := 1
Loop, % xKeys.MaxIndex()
    {
    if flagFirst = 1
        {
        DDLString := xKeys[A_Index] "||"
        flagFirst := 0
        }
    else
        {
        DDLString .= xKeys[A_Index] "|"
        }
    }
;msgbox %DDLString%
;AltSubmit: Uses alternate submit method. For DropDownList, ComboBox, and ListBox this causes the Gui
;Submit command to store the position of the selected item rather than its text. 
Gui Add, DropDownList, +AltSubmit vPresets x32 y260 w400 hwndDDLPRESET, %DDLString%

Gui Add, Text, x32 y290 w400 h23 +0x200, ffmpeg manual command...
Gui Add, Edit, vEdit_ffmpeg x31 y320 w400 h100 

Gui, Add, CheckBox, x31 y440 vCheckBox1 gCB_hvenc, Use HVENC ; can set to checked
Gui Add, DropDownList, vHvenc_b x120 y436 w100 hwndDDLHVENC_B, 10000K||50000K|100000K|200000K|300000K|400000K|500000K|800000K|1000000K

Gui Add, Button, x31 y530 w80 h23, Test2
Gui Add, Button, x126 y500 w80 h42 gCaptureWebcam, &Capture!
Gui Add, Button, x210 y500 w80 h42 gStop, Stop Rec!
Gui Add, Button, x300 y500 w60 h42 gPlay, &Play
Gui Add, Button, x370 y500 w80 h42 gExit, E&xit

Gui Show, w470 h560, GUIWebcam
Return

CB_hvenc:
Gui, Submit, NoHide
CB_hvenc = %CheckBox1%
;msgbox %CB_hvenc%
return

CMDload_devices:
GuiControl,, MyDevicesDLL, |%ListDevices% ; this will overwrite the choices in the list with the same values, effectively 're-setting' it to have nothing selected
DDLCount := 0

; will turn off for now
;Run, %comspec% /c ffmpeg -list_devices true -f dshow -i dummy -hide_banner 2> mydevices.txt
;sleep 2000

; would like to do all in one loop, but easier to split apart for now
FileRead, Contents, mydevices.txt
    loop,parse,contents,`n, `r
    {
  textline := InStr(A_LoopField,"(video)")
        ;msgbox Textline: %textline% 
        if textline > 0
        {
        OutputVar := RegExMatch(A_LoopField, """.+.?""",var1)
        ; if I want to remove quotes "
        ;StringReplace, var1,var1,`", , All 
            if DDLCount = 0
            {
            ; if first, we want first item selected with ||
            GuiControl,, MyDevicesDLL_Video, %  var1 "||"
            DDLCount = DDLCount + 1
            }
            else
            {
            GuiControl,, MyDevicesDLL_Video, %  var1 "|"
            }
        ;MsgBox, %OutputVar% & %var1%
        }
       }
    
; AUDIO DEVICES
FileRead, Contents, mydevices.txt
loop,parse,contents,`n, `r
    {
  textline := InStr(A_LoopField,"(audio)")
        ;msgbox Textline: %textline% 
        if textline > 0
        {
        OutputVar := RegExMatch(A_LoopField, """.+.?""",var1)
        ; if I want to remove quotes "
        ;StringReplace, var1,var1,`", , All 
            if DDLCount = 0
            {
            ; if first, we want first item selected with ||
            GuiControl,, MyDevicesDLL_Audio, %  var1 "||"
            DDLCount = DDLCount + 1
            }
            else
            {
            GuiControl,, MyDevicesDLL_Audio, %  var1 "|"
            }
        ;MsgBox, %OutputVar% & %var1%
        }
    }
    
return

CMDsave_devices:
{
guicontrolget, MyDevicesDLL_Video_selected,, MyDevicesDLL_Video
guicontrolget, MyDevicesDLL_Audio_selected,, MyDevicesDLL_Audio

; Creating an example CSV file
FileDelete, MyCaptureDevices.txt

FileAppend,
(
Key|Value
VideoDevice|%MyDevicesDLL_Video_selected%
AudioDevice|%MyDevicesDLL_Audio_selected%
), MyCaptureDevices.txt

}
return

; ***********************
; *** CAPTURE WEBCAM! ***
; ***********************
CaptureWebcam:
{
; *** Get current device selections
guicontrolget, MyDevicesDLL_Video_selected,, MyDevicesDLL_Video
guicontrolget, MyDevicesDLL_Audio_selected,, MyDevicesDLL_Audio
guicontrolget, edit_filename,,CaptureFilename

guicontrolget, Preset_selected,, Presets
;msgbox %Preset_selected%

; xCMDs array equals xKeys (or index of listbox)  We can do this using +AltSubmit
ffmpeg_command := xCmds[Preset_selected] ; start command string

StringReplace  ffmpeg_command, ffmpeg_command, argVideo, %MyDevicesDLL_Video_selected%
StringReplace  ffmpeg_command, ffmpeg_command, argAudio, %MyDevicesDLL_Audio_selected%
StringReplace  ffmpeg_command, ffmpeg_command, argFilename, %edit_filename%

; Use HVENC (GPU)?
;-c:v h264_nvenc -b:v 0 -maxrate:v 500000K
;-c:v libx264 -crf 0 -preset ultrafast
; -c:a aac -b:a 128k
;arg_CODEC_Video arg_CODEC_Audio
    if CB_hvenc = 1
    {
    guicontrolget, Hvenc_b_selected,, Hvenc_b
    StringReplace  ffmpeg_command, ffmpeg_command, arg_CODEC_Video, -c:v h264_nvenc -b:v 0 -maxrate:v %Hvenc_b_selected%
    }
    else
    {
    StringReplace  ffmpeg_command, ffmpeg_command, arg_CODEC_Video, -c:v libx264 -crf 0 -preset ultrafast 
    }
; Put in options for AUDIO later
StringReplace  ffmpeg_command, ffmpeg_command, arg_CODEC_Audio, -c:a aac -b:a 128k

;msgbox %ffmpeg_command%
Clipboard := ffmpeg_command

;Gui, Submit, NoHide
GuiControl,, Edit_ffmpeg, %Clipboard%
;, %comspec% /k
RunWait %comspec% /k %ffmpeg_command%,,,ffmpegPID
;WinWait ahk_pid %ffmpegID%
;msgbox %ffmpegID%
;Run ffmpeg %ffmpeg_command%

}
return

Stop:
{
;ControlGetFocus ffmpegPID, A
;SendMessage 0x113, 1, , %ffmpegPID%, A
;ConsoleSend(chr(0x113), "ahk_class ConsoleWindowClass")
;ConsoleSend(chr(0x03), "ahk_class ConsoleWindowClass")
;ConsoleSend(chr(0x03), "ahk_class ConsoleWindowClass")
WinActivate, ahk_exe ffmpeg.exe
WinShow, ahk_pid %ffmpegPID%
Send q

;Send % chr(0x03)
;Send chr(0x03)
;ControlSend, , chr(0x113), ahk_pid %ffmpegPID%  ; send ctrl-c to command window 
;Send ^c
;WinWait ahk_pid %ffmpegPID%
;WinActivate ahk_pid %ffmpegPID%
;Send ^c
;WinWaitActive, %ComSpec% ahk_pid %ffmpegPID%
;WinShow, ahk_pid %ffmpegPID%
;SendInput ^c

;Sleep, 3000 ; wait 3 seconds so you can see the window
;q{Enter}
;ControlSend, , ^c, ahk_class ConsoleWindowClass 
;ControlSend, , chr(0x03), ahk_pid %ffmpegPID%  ; send ctrl-c to command window which stops 
;the recording
;{Ctrl Down}{c Down}
;	ControlSend,, ^c, % "ahk_pid " ProcessID ; Send ctrl-c to command window which stops the recording.
;	SplashTextOff
;	SplashTextOn, 300, 80, Recording Stopped, Check the video file of where you saved it to and enjoy your recorded session.
;	Sleep 3000
;	SplashTextOff
}
Return

Play(CtrlHwnd, GuiEvent, EventInfo, ErrLevel := "") {
guicontrolget, edit_filename,,CaptureFilename
RunWait, mpv.exe /k %edit_filename%
}
return

Test1(CtrlHwnd, GuiEvent, EventInfo, ErrLevel := "") {
msgbox %CB_hvenc%
}
return

Exit(CtrlHwnd, GuiEvent, EventInfo, ErrLevel := "") {
ExitApp
}
return

; Sends text to a console's input stream. WinTitle may specify any window in
; the target process. Since each process may be attached to only one console,
; ConsoleSend fails if the script is already attached to a console.
ConsoleSend(text, WinTitle="", WinText="", ExcludeTitle="", ExcludeText="")
{
    WinGet, pid, PID, %WinTitle%, %WinText%, %ExcludeTitle%, %ExcludeText%
    if !pid
        return false, ErrorLevel:="window"
    ; Attach to the console belonging to %WinTitle%'s process.
    if !DllCall("AttachConsole", "uint", pid)
        return false, ErrorLevel:="AttachConsole"
    hConIn := DllCall("CreateFile", "str", "CONIN$", "uint", 0xC0000000
                , "uint", 0x3, "uint", 0, "uint", 0x3, "uint", 0, "uint", 0)
    if hConIn = -1
        return false, ErrorLevel:="CreateFile"
    
    VarSetCapacity(ir, 24, 0)       ; ir := new INPUT_RECORD
    NumPut(1, ir, 0, "UShort")      ; ir.EventType := KEY_EVENT
    NumPut(1, ir, 8, "UShort")      ; ir.KeyEvent.wRepeatCount := 1
    ; wVirtualKeyCode, wVirtualScanCode and dwControlKeyState are not needed,
    ; so are left at the default value of zero.
    
    Loop, Parse, text ; for each character in text
    {
        NumPut(Asc(A_LoopField), ir, 14, "UShort")
        
        NumPut(true, ir, 4, "Int")  ; ir.KeyEvent.bKeyDown := true
        gosub ConsoleSendWrite
        
        NumPut(false, ir, 4, "Int") ; ir.KeyEvent.bKeyDown := false
        gosub ConsoleSendWrite
    }
    gosub ConsoleSendCleanup
    return true
    
    ConsoleSendWrite:
        if ! DllCall("WriteConsoleInput", "uint", hconin, "uint", &ir, "uint", 1, "uint*", 0)
        {
            gosub ConsoleSendCleanup
            return false, ErrorLevel:="WriteConsoleInput"
        }
    return
    
    ConsoleSendCleanup:
        if (hConIn!="" && hConIn!=-1)
            DllCall("CloseHandle", "uint", hConIn)
        ; Detach from %WinTitle%'s console.
        DllCall("FreeConsole")
    return
}


GuiEscape:
GuiClose:
    ExitApp
